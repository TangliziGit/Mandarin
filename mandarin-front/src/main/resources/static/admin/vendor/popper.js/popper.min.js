/*
 Copyright (C) Federico Zivolo 2018
 Distributed under the MIT License (license terms are at http://opensource.org/licenses/MIT).
 */var e = typeof window !== 'undefined' && typeof document !== 'undefined'; const t = ['Edge', 'Trident', 'Firefox']; let o = 0; for (let n = 0; n < t.length; n += 1) if (e && navigator.userAgent.indexOf(t[n]) >= 0) { o = 1; break } function n (e) { let t = !1; return () => { t || (t = !0, window.Promise.resolve().then(() => { t = !1, e() })) } } function i (e) { let t = !1; return () => { t || (t = !0, setTimeout(() => { t = !1, e() }, o)) } } const r = e && window.Promise; var p = r ? n : i; function d (e) { return e && {}.toString.call(e) === '[object Function]' } function s (e, t) { if (e.nodeType !== 1) return []; const o = getComputedStyle(e, null); return t ? o[t] : o } function f (e) { return e.nodeName === 'HTML' ? e : e.parentNode || e.host } function a (e) { if (!e) return document.body; switch (e.nodeName) { case 'HTML':case 'BODY':return e.ownerDocument.body; case '#document':return e.body } const {overflow: t, overflowX: o, overflowY: n} = s(e); return /(auto|scroll|overlay)/.test(t + n + o) ? e : a(f(e)) } const l = e && !!(window.MSInputMethodContext && document.documentMode), m = e && /MSIE 10/.test(navigator.userAgent); function h (e) { return e === 11 ? l : e === 10 ? m : l || m } function c (e) { if (!e) return document.documentElement; const t = h(10) ? document.body : null; let o = e.offsetParent; for (;o === t && e.nextElementSibling;)o = (e = e.nextElementSibling).offsetParent; const n = o && o.nodeName; return n && n !== 'BODY' && n !== 'HTML' ? ['TD', 'TABLE'].indexOf(o.nodeName) !== -1 && s(o, 'position') === 'static' ? c(o) : o : e ? e.ownerDocument.documentElement : document.documentElement } function u (e) { const {nodeName: t} = e; return t !== 'BODY' && (t === 'HTML' || c(e.firstElementChild) === e) } function g (e) { return e.parentNode === null ? e : g(e.parentNode) } function b (e, t) { if (!e || !e.nodeType || !t || !t.nodeType) return document.documentElement; const o = e.compareDocumentPosition(t) & Node.DOCUMENT_POSITION_FOLLOWING, n = o ? e : t, i = o ? t : e, r = document.createRange(); r.setStart(n, 0), r.setEnd(i, 0); const {commonAncestorContainer: p} = r; if (e !== p && t !== p || n.contains(i)) return u(p) ? p : c(p); const d = g(e); return d.host ? b(d.host, t) : b(e, g(t).host) } function w (e, t = 'top') { const o = t === 'top' ? 'scrollTop' : 'scrollLeft', n = e.nodeName; if (n === 'BODY' || n === 'HTML') { const t = e.ownerDocument.documentElement, n = e.ownerDocument.scrollingElement || t; return n[o] } return e[o] } function y (e, t, o = !1) { const n = w(t, 'top'), i = w(t, 'left'), r = o ? -1 : 1; return e.top += n * r, e.bottom += n * r, e.left += i * r, e.right += i * r, e } function E (e, t) { const o = t === 'x' ? 'Left' : 'Top', n = o == 'Left' ? 'Right' : 'Bottom'; return parseFloat(e[`border${o}Width`], 10) + parseFloat(e[`border${n}Width`], 10) } function x (e, t, o, n) { return Math.max(t[`offset${e}`], t[`scroll${e}`], o[`client${e}`], o[`offset${e}`], o[`scroll${e}`], h(10) ? o[`offset${e}`] + n[`margin${e === 'Height' ? 'Top' : 'Left'}`] + n[`margin${e === 'Height' ? 'Bottom' : 'Right'}`] : 0) } function v () { const e = document.body, t = document.documentElement, o = h(10) && getComputedStyle(t); return {height: x('Height', e, t, o), width: x('Width', e, t, o)} } var O = Object.assign || function (e) { for (var t, o = 1; o < arguments.length; o++) for (var n in t = arguments[o], t)Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]); return e }; function L (e) { return O({}, e, {right: e.left + e.width, bottom: e.top + e.height}) } function S (e) { let t = {}; try { if (h(10)) { t = e.getBoundingClientRect(); const o = w(e, 'top'), n = w(e, 'left'); t.top += o, t.left += n, t.bottom += o, t.right += n } else t = e.getBoundingClientRect() } catch (t) {} const o = {left: t.left, top: t.top, width: t.right - t.left, height: t.bottom - t.top}, n = e.nodeName === 'HTML' ? v() : {}, i = n.width || e.clientWidth || o.right - o.left, r = n.height || e.clientHeight || o.bottom - o.top; let p = e.offsetWidth - i, d = e.offsetHeight - r; if (p || d) { const t = s(e); p -= E(t, 'x'), d -= E(t, 'y'), o.width -= p, o.height -= d } return L(o) } function T (e, t, o = !1) { var n = Math.max; const i = h(10), r = t.nodeName === 'HTML', p = S(e), d = S(t), f = a(e), l = s(t), m = parseFloat(l.borderTopWidth, 10), c = parseFloat(l.borderLeftWidth, 10); o && t.nodeName === 'HTML' && (d.top = n(d.top, 0), d.left = n(d.left, 0)); let u = L({top: p.top - d.top - m, left: p.left - d.left - c, width: p.width, height: p.height}); if (u.marginTop = 0, u.marginLeft = 0, !i && r) { const e = parseFloat(l.marginTop, 10), t = parseFloat(l.marginLeft, 10); u.top -= m - e, u.bottom -= m - e, u.left -= c - t, u.right -= c - t, u.marginTop = e, u.marginLeft = t } return (i && !o ? t.contains(f) : t === f && f.nodeName !== 'BODY') && (u = y(u, t)), u } function D (e, t = !1) { var o = Math.max; const n = e.ownerDocument.documentElement, i = T(e, n), r = o(n.clientWidth, window.innerWidth || 0), p = o(n.clientHeight, window.innerHeight || 0), d = t ? 0 : w(n), s = t ? 0 : w(n, 'left'), f = {top: d - i.top + i.marginTop, left: s - i.left + i.marginLeft, width: r, height: p}; return L(f) } function N (e) { const t = e.nodeName; return t === 'BODY' || t === 'HTML' ? !1 : !(s(e, 'position') !== 'fixed') || N(f(e)) } function C (e) { if (!e || !e.parentElement || h()) return document.documentElement; let t = e.parentElement; for (;t && s(t, 'transform') === 'none';)t = t.parentElement; return t || document.documentElement } function P (e, t, o, n, i = !1) { let r = {top: 0, left: 0}; const p = i ? C(e) : b(e, t); if (n === 'viewport')r = D(p, i); else { let o; n === 'scrollParent' ? (o = a(f(t)), o.nodeName === 'BODY' && (o = e.ownerDocument.documentElement)) : n === 'window' ? o = e.ownerDocument.documentElement : o = n; const d = T(o, p, i); if (o.nodeName === 'HTML' && !N(p)) { const {height: e, width: t} = v(); r.top += d.top - d.marginTop, r.bottom = e + d.top, r.left += d.left - d.marginLeft, r.right = t + d.left } else r = d } return r.left += o, r.top += o, r.right -= o, r.bottom -= o, r } function B ({width: e, height: t}) { return e * t } function H (e, t, o, n, i, r = 0) { if (e.indexOf('auto') === -1) return e; const p = P(o, n, r, i), d = {top: {width: p.width, height: t.top - p.top}, right: {width: p.right - t.right, height: p.height}, bottom: {width: p.width, height: p.bottom - t.bottom}, left: {width: t.left - p.left, height: p.height}}, s = Object.keys(d).map((e) => O({key: e}, d[e], {area: B(d[e])})).sort((e, t) => t.area - e.area), f = s.filter(({width: e, height: t}) => e >= o.clientWidth && t >= o.clientHeight), a = f.length > 0 ? f[0].key : s[0].key, l = e.split('-')[1]; return a + (l ? `-${l}` : '') } function W (e, t, o, n = null) { const i = n ? C(t) : b(t, o); return T(o, i, n) } function k (e) { const t = getComputedStyle(e), o = parseFloat(t.marginTop) + parseFloat(t.marginBottom), n = parseFloat(t.marginLeft) + parseFloat(t.marginRight), i = {width: e.offsetWidth + n, height: e.offsetHeight + o}; return i } function A (e) { const t = {left: 'right', right: 'left', bottom: 'top', top: 'bottom'}; return e.replace(/left|right|bottom|top/g, (e) => t[e]) } function M (e, t, o) { o = o.split('-')[0]; const n = k(e), i = {width: n.width, height: n.height}, r = ['right', 'left'].indexOf(o) !== -1, p = r ? 'top' : 'left', d = r ? 'left' : 'top', s = r ? 'height' : 'width', f = r ? 'width' : 'height'; return i[p] = t[p] + t[s] / 2 - n[s] / 2, i[d] = o === d ? t[d] - n[f] : t[A(d)], i } function F (e, t) { return Array.prototype.find ? e.find(t) : e.filter(t)[0] } function I (e, t, o) { if (Array.prototype.findIndex) return e.findIndex((e) => e[t] === o); const n = F(e, (e) => e[t] === o); return e.indexOf(n) } function R (e, t, o) { const n = void 0 === o ? e : e.slice(0, I(e, 'name', o)); return n.forEach((e) => { e['function'] && console.warn('`modifier.function` is deprecated, use `modifier.fn`!'); const o = e['function'] || e.fn; e.enabled && d(o) && (t.offsets.popper = L(t.offsets.popper), t.offsets.reference = L(t.offsets.reference), t = o(t, e)) }), t } function U () { if (this.state.isDestroyed) return; let e = {instance: this, styles: {}, arrowStyles: {}, attributes: {}, flipped: !1, offsets: {}}; e.offsets.reference = W(this.state, this.popper, this.reference, this.options.positionFixed), e.placement = H(this.options.placement, e.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding), e.originalPlacement = e.placement, e.positionFixed = this.options.positionFixed, e.offsets.popper = M(this.popper, e.offsets.reference, e.placement), e.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute', e = R(this.modifiers, e), this.state.isCreated ? this.options.onUpdate(e) : (this.state.isCreated = !0, this.options.onCreate(e)) } function Y (e, t) { return e.some(({name: e, enabled: o}) => o && e === t) } function K (e) { const t = [!1, 'ms', 'Webkit', 'Moz', 'O'], o = e.charAt(0).toUpperCase() + e.slice(1); for (let n = 0; n < t.length; n++) { const i = t[n], r = i ? `${i}${o}` : e; if (typeof document.body.style[r] !== 'undefined') return r } return null } function j () { return this.state.isDestroyed = !0, Y(this.modifiers, 'applyStyle') && (this.popper.removeAttribute('x-placement'), this.popper.style.position = '', this.popper.style.top = '', this.popper.style.left = '', this.popper.style.right = '', this.popper.style.bottom = '', this.popper.style.willChange = '', this.popper.style[K('transform')] = ''), this.disableEventListeners(), this.options.removeOnDestroy && this.popper.parentNode.removeChild(this.popper), this } function q (e) { const t = e.ownerDocument; return t ? t.defaultView : window } function G (e, t, o, n) { const i = e.nodeName === 'BODY', r = i ? e.ownerDocument.defaultView : e; r.addEventListener(t, o, {passive: !0}), i || G(a(r.parentNode), t, o, n), n.push(r) } function z (e, t, o, n) { o.updateBound = n, q(e).addEventListener('resize', o.updateBound, {passive: !0}); const i = a(e); return G(i, 'scroll', o.updateBound, o.scrollParents), o.scrollElement = i, o.eventsEnabled = !0, o } function V () { this.state.eventsEnabled || (this.state = z(this.reference, this.options, this.state, this.scheduleUpdate)) } function _ (e, t) { return q(e).removeEventListener('resize', t.updateBound), t.scrollParents.forEach((e) => { e.removeEventListener('scroll', t.updateBound) }), t.updateBound = null, t.scrollParents = [], t.scrollElement = null, t.eventsEnabled = !1, t } function X () { this.state.eventsEnabled && (cancelAnimationFrame(this.scheduleUpdate), this.state = _(this.reference, this.state)) } function Q (e) { return e !== '' && !isNaN(parseFloat(e)) && isFinite(e) } function J (e, t) { Object.keys(t).forEach((o) => { let n = ''; ['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(o) !== -1 && Q(t[o]) && (n = 'px'), e.style[o] = t[o] + n }) } function Z (e, t) { Object.keys(t).forEach(function (o) { const n = t[o]; !1 === n ? e.removeAttribute(o) : e.setAttribute(o, t[o]) }) } function $ (e) { return J(e.instance.popper, e.styles), Z(e.instance.popper, e.attributes), e.arrowElement && Object.keys(e.arrowStyles).length && J(e.arrowElement, e.arrowStyles), e } function ee (e, t, o, n, i) { const r = W(i, t, e, o.positionFixed), p = H(o.placement, r, t, e, o.modifiers.flip.boundariesElement, o.modifiers.flip.padding); return t.setAttribute('x-placement', p), J(t, {position: o.positionFixed ? 'fixed' : 'absolute'}), o } function te (e, t) { var o = Math.round, n = Math.floor; const {x: i, y: r} = t, {popper: p} = e.offsets, d = F(e.instance.modifiers, (e) => e.name === 'applyStyle').gpuAcceleration; void 0 !== d && console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!'); const s = void 0 === d ? t.gpuAcceleration : d, f = c(e.instance.popper), a = S(f), l = {position: p.position}, m = {left: n(p.left), top: o(p.top), bottom: o(p.bottom), right: n(p.right)}, h = i === 'bottom' ? 'top' : 'bottom', u = r === 'right' ? 'left' : 'right', g = K('transform'); let b, w; if (w = h == 'bottom' ? -a.height + m.bottom : m.top, b = u == 'right' ? -a.width + m.right : m.left, s && g)l[g] = `translate3d(${b}px, ${w}px, 0)`, l[h] = 0, l[u] = 0, l.willChange = 'transform'; else { const e = h == 'bottom' ? -1 : 1, t = u == 'right' ? -1 : 1; l[h] = w * e, l[u] = b * t, l.willChange = `${h}, ${u}` } const y = {'x-placement': e.placement}; return e.attributes = O({}, y, e.attributes), e.styles = O({}, l, e.styles), e.arrowStyles = O({}, e.offsets.arrow, e.arrowStyles), e } function oe (e, t, o) { const n = F(e, ({name: e}) => e === t), i = !!n && e.some((e) => e.name === o && e.enabled && e.order < n.order); if (!i) { const e = `\`${t}\``, n = `\`${o}\``; console.warn(`${n} modifier is required by ${e} modifier in order to work, be sure to include it before ${e}!`) } return i } function ne (e, t) { if (!oe(e.instance.modifiers, 'arrow', 'keepTogether')) return e; let o = t.element; if (typeof o === 'string') { if (o = e.instance.popper.querySelector(o), !o) return e } else if (!e.instance.popper.contains(o)) return console.warn('WARNING: `arrow.element` must be child of its popper element!'), e; const n = e.placement.split('-')[0], {popper: i, reference: r} = e.offsets, p = ['left', 'right'].indexOf(n) !== -1, d = p ? 'height' : 'width', f = p ? 'Top' : 'Left', a = f.toLowerCase(), l = p ? 'left' : 'top', m = p ? 'bottom' : 'right', h = k(o)[d]; r[m] - h < i[a] && (e.offsets.popper[a] -= i[a] - (r[m] - h)), r[a] + h > i[m] && (e.offsets.popper[a] += r[a] + h - i[m]), e.offsets.popper = L(e.offsets.popper); const c = r[a] + r[d] / 2 - h / 2, u = s(e.instance.popper), g = parseFloat(u[`margin${f}`], 10), b = parseFloat(u[`border${f}Width`], 10); let w = c - e.offsets.popper[a] - g - b; return w = Math.max(Math.min(i[d] - h, w), 0), e.arrowElement = o, e.offsets.arrow = {[a]: Math.round(w), [l]: ''}, e } function ie (e) { if (e === 'end') return 'start'; return e === 'start' ? 'end' : e } var re = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start']; const pe = re.slice(3); function de (e, t = !1) { const o = pe.indexOf(e), n = pe.slice(o + 1).concat(pe.slice(0, o)); return t ? n.reverse() : n } const se = {FLIP: 'flip', CLOCKWISE: 'clockwise', COUNTERCLOCKWISE: 'counterclockwise'}; function fe (e, t) { if (Y(e.instance.modifiers, 'inner')) return e; if (e.flipped && e.placement === e.originalPlacement) return e; const o = P(e.instance.popper, e.instance.reference, t.padding, t.boundariesElement, e.positionFixed); let n = e.placement.split('-')[0], i = A(n), r = e.placement.split('-')[1] || '', p = []; switch (t.behavior) { case se.FLIP:p = [n, i]; break; case se.CLOCKWISE:p = de(n); break; case se.COUNTERCLOCKWISE:p = de(n, !0); break; default:p = t.behavior } return p.forEach((d, s) => { if (n !== d || p.length === s + 1) return e; n = e.placement.split('-')[0], i = A(n); const f = e.offsets.popper, a = e.offsets.reference, l = Math.floor, m = n === 'left' && l(f.right) > l(a.left) || n === 'right' && l(f.left) < l(a.right) || n === 'top' && l(f.bottom) > l(a.top) || n === 'bottom' && l(f.top) < l(a.bottom), h = l(f.left) < l(o.left), c = l(f.right) > l(o.right), u = l(f.top) < l(o.top), g = l(f.bottom) > l(o.bottom), b = n === 'left' && h || n === 'right' && c || n === 'top' && u || n === 'bottom' && g, w = ['top', 'bottom'].indexOf(n) !== -1, y = !!t.flipVariations && (w && r === 'start' && h || w && r === 'end' && c || !w && r === 'start' && u || !w && r === 'end' && g); (m || b || y) && (e.flipped = !0, (m || b) && (n = p[s + 1]), y && (r = ie(r)), e.placement = n + (r ? '-' + r : ''), e.offsets.popper = O({}, e.offsets.popper, M(e.instance.popper, e.offsets.reference, e.placement)), e = R(e.instance.modifiers, e, 'flip')) }), e } function ae (e) { const {popper: t, reference: o} = e.offsets, n = e.placement.split('-')[0], i = Math.floor, r = ['top', 'bottom'].indexOf(n) !== -1, p = r ? 'right' : 'bottom', d = r ? 'left' : 'top', s = r ? 'width' : 'height'; return t[p] < i(o[d]) && (e.offsets.popper[d] = i(o[d]) - t[s]), t[d] > i(o[p]) && (e.offsets.popper[d] = i(o[p])), e } function le (e, t, o, n) { var i = Math.max; const r = e.match(/((?:\-|\+)?\d*\.?\d*)(.*)/), p = +r[1], d = r[2]; if (!p) return e; if (d.indexOf('%') === 0) { let e; switch (d) { case '%p':e = o; break; case '%':case '%r':default:e = n } const i = L(e); return i[t] / 100 * p } if (d === 'vh' || d === 'vw') { let e; return e = d === 'vh' ? i(document.documentElement.clientHeight, window.innerHeight || 0) : i(document.documentElement.clientWidth, window.innerWidth || 0), e / 100 * p } return p } function me (e, t, o, n) { const i = [0, 0], r = ['right', 'left'].indexOf(n) !== -1, p = e.split(/(\+|\-)/).map((e) => e.trim()), d = p.indexOf(F(p, (e) => e.search(/,|\s/) !== -1)); p[d] && p[d].indexOf(',') === -1 && console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.'); const s = /\s*,\s*|\s+/; let f = d === -1 ? [p] : [p.slice(0, d).concat([p[d].split(s)[0]]), [p[d].split(s)[1]].concat(p.slice(d + 1))]; return f = f.map((e, n) => { const i = (n === 1 ? !r : r) ? 'height' : 'width'; let p = !1; return e.reduce((e, t) => e[e.length - 1] === '' && ['+', '-'].indexOf(t) !== -1 ? (e[e.length - 1] = t, p = !0, e) : p ? (e[e.length - 1] += t, p = !1, e) : e.concat(t), []).map((e) => le(e, i, t, o)) }), f.forEach((e, t) => { e.forEach((o, n) => { Q(o) && (i[t] += o * (e[n - 1] === '-' ? -1 : 1)) }) }), i } function he (e, {offset: t}) { const {placement: o, offsets: {popper: n, reference: i}} = e, r = o.split('-')[0]; let p; return p = Q(+t) ? [+t, 0] : me(t, n, i, r), r === 'left' ? (n.top += p[0], n.left -= p[1]) : r === 'right' ? (n.top += p[0], n.left += p[1]) : r === 'top' ? (n.left += p[0], n.top -= p[1]) : r === 'bottom' && (n.left += p[0], n.top += p[1]), e.popper = n, e } function ce (e, t) { let o = t.boundariesElement || c(e.instance.popper); e.instance.reference === o && (o = c(o)); const n = K('transform'), i = e.instance.popper.style, {top: r, left: p, [n]: d} = i; i.top = '', i.left = '', i[n] = ''; const s = P(e.instance.popper, e.instance.reference, t.padding, o, e.positionFixed); i.top = r, i.left = p, i[n] = d, t.boundaries = s; const f = t.priority; let a = e.offsets.popper; const l = {primary (e) { let o = a[e]; return a[e] < s[e] && !t.escapeWithReference && (o = Math.max(a[e], s[e])), {[e]: o} }, secondary (e) { const o = e === 'right' ? 'left' : 'top'; let n = a[o]; return a[e] > s[e] && !t.escapeWithReference && (n = Math.min(a[o], s[e] - (e === 'right' ? a.width : a.height))), {[o]: n} }}; return f.forEach((e) => { const t = ['left', 'top'].indexOf(e) === -1 ? 'secondary' : 'primary'; a = O({}, a, l[t](e)) }), e.offsets.popper = a, e } function ue (e) { const t = e.placement, o = t.split('-')[0], n = t.split('-')[1]; if (n) { const {reference: t, popper: i} = e.offsets, r = ['bottom', 'top'].indexOf(o) !== -1, p = r ? 'left' : 'top', d = r ? 'width' : 'height', s = {start: {[p]: t[p]}, end: {[p]: t[p] + t[d] - i[d]}}; e.offsets.popper = O({}, i, s[n]) } return e } function ge (e) { if (!oe(e.instance.modifiers, 'hide', 'preventOverflow')) return e; const t = e.offsets.reference, o = F(e.instance.modifiers, (e) => e.name === 'preventOverflow').boundaries; if (t.bottom < o.top || t.left > o.right || t.top > o.bottom || t.right < o.left) { if (!0 === e.hide) return e; e.hide = !0, e.attributes['x-out-of-boundaries'] = '' } else { if (!1 === e.hide) return e; e.hide = !1, e.attributes['x-out-of-boundaries'] = !1 } return e } function be (e) { const t = e.placement, o = t.split('-')[0], {popper: n, reference: i} = e.offsets, r = ['left', 'right'].indexOf(o) !== -1, p = ['top', 'left'].indexOf(o) === -1; return n[r ? 'left' : 'top'] = i[o] - (p ? n[r ? 'width' : 'height'] : 0), e.placement = A(t), e.offsets.popper = L(n), e } var we = {shift: {order: 100, enabled: !0, fn: ue}, offset: {order: 200, enabled: !0, fn: he, offset: 0}, preventOverflow: {order: 300, enabled: !0, fn: ce, priority: ['left', 'right', 'top', 'bottom'], padding: 5, boundariesElement: 'scrollParent'}, keepTogether: {order: 400, enabled: !0, fn: ae}, arrow: {order: 500, enabled: !0, fn: ne, element: '[x-arrow]'}, flip: {order: 600, enabled: !0, fn: fe, behavior: 'flip', padding: 5, boundariesElement: 'viewport'}, inner: {order: 700, enabled: !1, fn: be}, hide: {order: 800, enabled: !0, fn: ge}, computeStyle: {order: 850, enabled: !0, fn: te, gpuAcceleration: !0, x: 'bottom', y: 'right'}, applyStyle: {order: 900, enabled: !0, fn: $, onLoad: ee, gpuAcceleration: void 0}}, ye = {placement: 'bottom', positionFixed: !1, eventsEnabled: !0, removeOnDestroy: !1, onCreate: () => {}, onUpdate: () => {}, modifiers: we}; class Ee {constructor (e, t, o = {}) { this.scheduleUpdate = () => requestAnimationFrame(this.update), this.update = p(this.update.bind(this)), this.options = O({}, Ee.Defaults, o), this.state = {isDestroyed: !1, isCreated: !1, scrollParents: []}, this.reference = e && e.jquery ? e[0] : e, this.popper = t && t.jquery ? t[0] : t, this.options.modifiers = {}, Object.keys(O({}, Ee.Defaults.modifiers, o.modifiers)).forEach((e) => { this.options.modifiers[e] = O({}, Ee.Defaults.modifiers[e] || {}, o.modifiers ? o.modifiers[e] : {}) }), this.modifiers = Object.keys(this.options.modifiers).map((e) => O({name: e}, this.options.modifiers[e])).sort((e, t) => e.order - t.order), this.modifiers.forEach((e) => { e.enabled && d(e.onLoad) && e.onLoad(this.reference, this.popper, this.options, e, this.state) }), this.update(); const n = this.options.eventsEnabled; n && this.enableEventListeners(), this.state.eventsEnabled = n }update () { return U.call(this) }destroy () { return j.call(this) }enableEventListeners () { return V.call(this) }disableEventListeners () { return X.call(this) }}Ee.Utils = (typeof window === 'undefined' ? global : window).PopperUtils, Ee.placements = re, Ee.Defaults = ye; export default Ee
// # sourceMappingURL=popper.min.js.map
